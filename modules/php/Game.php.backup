<?php
declare(strict_types=1);
/**
 *------
 * BGA framework: Gregory Isabelli & Emmanuel Colin & BoardGameArena
 * matrevx implementation : © Mike McKeever, Jack McKeever, Bryan Chase <bryanchase@yahoo.com>
 *
 * This code has been produced on the BGA studio platform for use on http://boardgamearena.com.
 * See http://en.boardgamearena.com/#!doc/Studio for more information.
 * -----
 *
 * Game.php
 *
 * This is the main file for your game logic.
 *
 * In this PHP file, you are going to defines the rules of the game.
 */

namespace Bga\Games\matrevx;

require_once(APP_GAMEMODULE_PATH . "module/table/table.game.php");

class Game extends \Table
{
    private static array $CARD_TYPES;
    private static array $WRESTLERS;
	private static array $SCRAMBLE_CARDS;

    /**
     * Your global variables labels:
     */
    public function __construct()
    {
        parent::__construct();

    $this->initGameStateLabels([
        "current_period" => 10,
        "current_round" => 11,
        "position_offense" => 12,
        "position_defense" => 13,
        "red_die" => 14,
        "blue_die" => 15,
        // Round state tracking
        "first_player_id" => 16,
        "second_player_id" => 17,
        "first_player_card" => 18,
        "second_player_card" => 19,
        // Die choice tracking
        "first_player_die_choice" => 20,
        "second_player_die_choice" => 21,
        "first_player_die_value" => 22,
        "second_player_die_value" => 23,
        // NEW: Simple momentum tracking
        "momentum_player" => 24,           // Which player has momentum (0 = no momentum)
        "current_scramble_card" => 25,  // ADD THIS LINE
        // Existing variants
        "my_first_game_variant" => 100,
        "my_second_game_variant" => 101,
    ]);
    
    // Load material from material.inc.php
    $material = require(__DIR__ . '/material.inc.php');
    self::$CARD_TYPES = $material['cardTypes'];
    self::$WRESTLERS = $material['wrestlers'];
    self::$SCRAMBLE_CARDS = $material['scrambleCards']; // ADD THIS LINE
}
    /**
     * Get current position for a player - IMPROVED with debugging and error handling
     */
    private function getPlayerPosition(int $player_id): string
    {
        $offense_player = $this->getGameStateValue("position_offense");
        $defense_player = $this->getGameStateValue("position_defense");
        
        $this->trace("getPlayerPosition: Player $player_id, offense_player=$offense_player, defense_player=$defense_player");
        
        // ADD: Check if positions are set
        if ($offense_player == 0 || $defense_player == 0) {
            $this->trace("getPlayerPosition: WARNING - Positions not set yet, defaulting to offense");
            return "offense";
        }
        
        // For now, we only have offense/defense positions
        if ($player_id == $offense_player) {
            $this->trace("getPlayerPosition: Player $player_id is OFFENSE");
            return "offense";
        } else if ($player_id == $defense_player) {
            $this->trace("getPlayerPosition: Player $player_id is DEFENSE");
            return "defense";
        }
        
        // Default fallback - SHOULD NOT HAPPEN
        $this->trace("getPlayerPosition: WARNING - Player $player_id position unknown, defaulting to offense");
        return "offense";
    }

    /**
     * Get available cards based on player's current position
     */
    private function getAvailableCardsForPosition(string $position): array
    {
        $available_cards = [];
        
        foreach (self::$CARD_TYPES as $card_id => $card) {
            // Include cards that match the position OR are "any" position
            if ($card['position'] === $position || $card['position'] === 'any') {
                $available_cards[] = $card_id;
            }
        }
        
        return $available_cards;
    }

    /**
     * Check if player can afford to play a card - IMPROVED with safety checks
     */
    private function canAffordCard(int $player_id, int $card_id): bool
    {
        // ADD: Check if card exists
        if (!isset(self::$CARD_TYPES[$card_id])) {
            $this->trace("canAffordCard: Card $card_id does not exist");
            return false;
        }
        
        $card = self::$CARD_TYPES[$card_id];
        
        // Get player's current resources
        $player_data = $this->getObjectFromDB(
            "SELECT conditioning, special_tokens FROM player WHERE player_id = $player_id"
        );
        
        if (!$player_data) {
            $this->trace("canAffordCard: Could not find player data for $player_id");
            return false;
        }
        
        // Ensure we have valid values
        $conditioning = intval($player_data['conditioning']);
        $tokens = intval($player_data['special_tokens']);
        $card_conditioning_cost = intval($card['conditioning_cost']);
        $card_token_cost = intval($card['special_tokens']);
        
        // Check if player has enough conditioning and special tokens
        return ($conditioning >= $card_conditioning_cost) && 
               ($tokens >= $card_token_cost);
    }

    /**
     * FINAL: Wrestler selection with correct BGA methods only
     */
    public function actSelectWrestler(int $wrestler_id): void
    {
        $player_id = (int)$this->getCurrentPlayerId();
        
        $this->trace("actSelectWrestler: START - Player $player_id selecting wrestler $wrestler_id");
        
        // Validate wrestler exists
        if (!isset(self::$WRESTLERS[$wrestler_id])) {
            throw new \BgaUserException('Invalid wrestler selection');
        }

        // Check if player already has a wrestler
        $current_wrestler = $this->getUniqueValueFromDB("SELECT wrestler_id FROM player WHERE player_id = $player_id");
        if ($current_wrestler !== null && intval($current_wrestler) > 0) {
            throw new \BgaUserException('You have already selected a wrestler');
        }

        // Check if wrestler already taken by another player
        $existing_player = $this->getUniqueValueFromDB("SELECT player_id FROM player WHERE wrestler_id = $wrestler_id AND player_id != $player_id");
        if ($existing_player) {
            throw new \BgaUserException('Wrestler already selected by another player');
        }

        // Assign wrestler to player
        $wrestler = self::$WRESTLERS[$wrestler_id];
        
        $this->trace("actSelectWrestler: Updating player $player_id with wrestler data");
        $this->DbQuery("UPDATE player SET wrestler_id = $wrestler_id WHERE player_id = $player_id");
        $this->DbQuery("UPDATE player SET conditioning = {$wrestler['conditioning_p1']} WHERE player_id = $player_id");
        $this->DbQuery("UPDATE player SET offense = {$wrestler['offense']} WHERE player_id = $player_id");
        $this->DbQuery("UPDATE player SET defense = {$wrestler['defense']} WHERE player_id = $player_id");
        $this->DbQuery("UPDATE player SET top = {$wrestler['top']} WHERE player_id = $player_id");
        $this->DbQuery("UPDATE player SET bottom = {$wrestler['bottom']} WHERE player_id = $player_id");
        $this->DbQuery("UPDATE player SET special_tokens = {$wrestler['special_tokens']} WHERE player_id = $player_id");

        $this->trace("actSelectWrestler: Successfully updated player $player_id with wrestler $wrestler_id");

        // Get player name from database for notification
        $player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $player_id");
        if (!$player_name) {
            $player_name = "Player $player_id"; // Fallback if name not found
        }
        
        // Notify all players
        $this->notifyAllPlayers("wrestlerSelected", '${player_name} selected ${wrestler_name}', [
            "player_id" => $player_id,
            "player_name" => $player_name,
            "wrestler_id" => $wrestler_id,
            "wrestler_name" => $wrestler['name'],
        ]);

        // Make player inactive in multiactive state
        $this->gamestate->setPlayerNonMultiactive($player_id, '');
        $this->trace("actSelectWrestler: Set player $player_id as non-multiactive");
        
        // Better query to count players with wrestlers
        $players_with_wrestlers = $this->getUniqueValueFromDB("SELECT COUNT(*) FROM player WHERE wrestler_id >= 1");     
        $total_players = $this->getUniqueValueFromDB("SELECT COUNT(*) FROM player");
        
        $this->trace("actSelectWrestler: Progress - $players_with_wrestlers / $total_players players have selected");

        // If all players have selected, transition to next state
        if ($players_with_wrestlers >= $total_players) {
            $this->trace("actSelectWrestler: All players selected - checking if transition needed");
            $current_state = $this->gamestate->state_id();
            if ($current_state == 2) { // Only transition if still in wrestler selection state
                $this->trace("actSelectWrestler: Transitioning to next state");
                $this->gamestate->nextState('allSelected');
            } else {
                $this->trace("actSelectWrestler: Already transitioned to state $current_state, no action needed");
            }
        } else {
            $this->trace("actSelectWrestler: Still waiting - need " . ($total_players - $players_with_wrestlers) . " more selections");
        }
    }

/**
 * Enhanced scramble resolution with dice rolling challenge
 */
public function actResolveScramble(): void
{
    $player_id = (int)$this->getCurrentPlayerId();
    $this->trace("actResolveScramble: Player $player_id resolving dice challenge scramble card");
    
    // Validate that this is the offense player
    $offense_player_id = (int)$this->getGameStateValue("position_offense");
    if ($player_id != $offense_player_id) {
        throw new \BgaUserException("Only the offense player can resolve the scramble card");
    }
    
    // Get player name
    $player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $player_id");
    if (!$player_name) {
        $player_name = "Player $player_id";
    }
    
    // Execute the dice challenge
    $challenge_result = $this->executeDiceChallenge($player_id);
    
    // Apply results based on outcome
    if ($challenge_result['success']) {
        $points = $challenge_result['points'];
        $outcome_type = $challenge_result['outcome_type'];
        
        $this->DbQuery("UPDATE player SET player_score = player_score + $points WHERE player_id = $player_id");
        
        $new_score = (int)$this->getUniqueValueFromDB("SELECT player_score FROM player WHERE player_id = $player_id");
        
        $this->notifyAllPlayers("scrambleResolved", '${player_name} completes the dice challenge! ${outcome_description}', [
            "player_id" => $player_id,
            "player_name" => $player_name,
            "outcome" => "success",
            "outcome_type" => $outcome_type,
            "points" => $points,
            "new_score" => $new_score,
            "rounds_taken" => $challenge_result['rounds_taken'],
            "final_roll" => $challenge_result['final_roll'],
            "all_rolls" => $challenge_result['all_rolls'],
            "outcome_description" => $challenge_result['description'],
            "description" => "Dice challenge completed successfully"
        ]);
        
        // Send score update notification
        $this->notifyAllPlayers("playerScoreUpdate", '${player_name} score updated', [
            "player_id" => $player_id,
            "player_name" => $player_name,
            "new_score" => $new_score,
            "points_gained" => $points
        ]);
        
    } else {
        // Challenge failed
        $this->notifyAllPlayers("scrambleResolved", '${player_name} fails the dice challenge! No points scored.', [
            "player_id" => $player_id,
            "player_name" => $player_name,
            "outcome" => "failure",
            "points" => 0,
            "rounds_taken" => $challenge_result['rounds_taken'],
            "all_rolls" => $challenge_result['all_rolls'],
            "description" => "Failed to roll 18+ within 5 attempts"
        ]);
        
        // Apply failure penalty (lose momentum)
        $this->setGameStateValue("momentum_player", 0);
    }
    
    $this->gamestate->nextState("resolved");
}
    /**
     * NEW: Manual dice rolling action
     */
    public function actRollDice(): void
    {
        $player_id = (int)$this->getCurrentPlayerId();
        $state_name = $this->gamestate->state()['name'];
        
        $this->trace("actRollDice: Player $player_id rolling dice in state $state_name");
        
        // Get the card played by this player to determine die type
        $first_player_id = (int)$this->getGameStateValue("first_player_id");
        $second_player_id = (int)$this->getGameStateValue("second_player_id");
        $first_card_id = $this->getGameStateValue("first_player_card");
        $second_card_id = $this->getGameStateValue("second_player_card");
        
        $card_id = null;
        $die_choice_slot = null;
        $die_value_slot = null;
        
        if ($player_id == $first_player_id) {
            $card_id = $first_card_id;
            $die_choice_slot = "first_player_die_choice";
            $die_value_slot = "first_player_die_value";
        } else if ($player_id == $second_player_id) {
            $card_id = $second_card_id;
            $die_choice_slot = "second_player_die_choice";
            $die_value_slot = "second_player_die_value";
        }
        
        if (!$card_id) {
            throw new \BgaUserException("Could not determine player's card");
        }
        
        $card = self::$CARD_TYPES[$card_id];
        $action = $card['action'];
        
        // Determine die type from card action
        $die_type = null;
        $die_choice_numeric = 0;
        
        if ($action === 'roll_speed') {
            $die_type = 'blue';
            $die_choice_numeric = 2;
        } else if ($action === 'roll_strength') {
            $die_type = 'red';
            $die_choice_numeric = 1;
        } else {
            throw new \BgaUserException("This card does not require a die roll");
        }
        
        // Roll the die
        $die_value = 0;
        $die_face = 0;
        
        if ($die_type === 'red') {
            $die_value = $this->rollRedDie();
            $die_face = $this->getGameStateValue("red_die");
        } else {
            $die_value = $this->rollBlueDie();
            $die_face = $this->getGameStateValue("blue_die");
        }
        
        // Store the results
        $this->setGameStateValue($die_choice_slot, $die_choice_numeric);
        $this->setGameStateValue($die_value_slot, $die_value);
        
        // Apply dice costs
        $this->applyDiceCosts($player_id, $die_type);
        
        // Get updated resources
        $new_tokens = (int)$this->getUniqueValueFromDB("SELECT special_tokens FROM player WHERE player_id = $player_id");
        $new_conditioning = (int)$this->getUniqueValueFromDB("SELECT conditioning FROM player WHERE player_id = $player_id");
        
        // Get player name
        $player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $player_id");
        if (!$player_name) {
            $player_name = "Player $player_id";
        }
        
        $die_label = $die_type === 'red' ? 'Red (STRENGTH)' : 'Blue (SPEED)';
        
        // Notify about the roll
        $this->notifyAllPlayers("diceRolled", '${player_name} rolled ${die_label}: ${die_value}', [
            "player_id" => $player_id,
            "player_name" => $player_name,
            "die_choice" => $die_type,
            "die_label" => $die_label,
            "die_face" => $die_face,
            "die_value" => $die_value,
            "new_tokens" => $new_tokens,
            "new_conditioning" => $new_conditioning
        ]);
        
        $this->gamestate->nextState("diceRolled");
    }

    /**
     * NEW: Set first player for manual dice rolling
     */
    public function stFirstPlayerRollDice(): void
    {
        $this->trace("stFirstPlayerRollDice: START");
        
        $first_player_id = (int)$this->getGameStateValue("first_player_id");
        
        if (!$first_player_id) {
            throw new \BgaSystemException("No first player set for dice rolling");
        }
        
        $this->gamestate->changeActivePlayer($first_player_id);
        
        $this->trace("stFirstPlayerRollDice: Set first player $first_player_id as active");
    }

    /**
     * NEW: Set second player for manual dice rolling
     */
    public function stSecondPlayerRollDice(): void
    {
        $this->trace("stSecondPlayerRollDice: START");
        
        $second_player_id = (int)$this->getGameStateValue("second_player_id");
        
        if (!$second_player_id) {
            throw new \BgaSystemException("No second player set for dice rolling");
        }
        
        $this->gamestate->changeActivePlayer($second_player_id);
        
        $this->trace("stSecondPlayerRollDice: Set second player $second_player_id as active");
    }



	// 3. FIX: Add method to handle any other scoring situations
	private function awardPoints(int $player_id, int $points, string $reason = ""): void
	{
		$this->trace("awardPoints: Awarding $points points to player $player_id for: $reason");
		
		if ($points > 0) {
			$this->DbQuery("UPDATE player SET player_score = player_score + $points WHERE player_id = $player_id");
			
			$new_score = (int)$this->getUniqueValueFromDB("SELECT player_score FROM player WHERE player_id = $player_id");
			$player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $player_id");
			
			// Notify all players about score update
			$this->notifyAllPlayers("playerScoreUpdate", '${player_name} scores ${points} points', [
				"player_id" => $player_id,
				"player_name" => $player_name,
				"new_score" => $new_score,
				"points_gained" => $points,
				"reason" => $reason
			]);
		}
	}

/**
 * Execute the dice challenge for scramble card
 */
private function executeDiceChallenge(int $player_id): array
{
    $this->trace("executeDiceChallenge: Starting dice challenge for player $player_id");
    
    $max_attempts = 5;
    $target = 18;
    $all_rolls = [];
    $rounds_taken = 0;
    
    for ($attempt = 1; $attempt <= $max_attempts; $attempt++) {
        // Roll 2d10 + 2d12
        $d10_1 = bga_rand(1, 10);
        $d10_2 = bga_rand(1, 10);
        $d12_1 = bga_rand(1, 12);
        $d12_2 = bga_rand(1, 12);
        
        $total = $d10_1 + $d10_2 + $d12_1 + $d12_2;
        $rounds_taken = $attempt;
        
        $roll_data = [
            "attempt" => $attempt,
            "d10_1" => $d10_1,
            "d10_2" => $d10_2,
            "d12_1" => $d12_1,
            "d12_2" => $d12_2,
            "total" => $total,
            "success" => $total >= $target
        ];
        
        $all_rolls[] = $roll_data;
        
        $this->trace("executeDiceChallenge: Attempt $attempt - d10: $d10_1+$d10_2, d12: $d12_1+$d12_2, total: $total");
        
        if ($total >= $target) {
            // Success! Determine outcome based on rounds taken
            if ($rounds_taken <= 2) {
                // Critical success (1-2 rounds)
                return [
                    "success" => true,
                    "outcome_type" => "critical_success",
                    "points" => 4,
                    "rounds_taken" => $rounds_taken,
                    "final_roll" => $total,
                    "all_rolls" => $all_rolls,
                    "description" => "Critical success! Rolled $total in just $rounds_taken round(s)!"
                ];
            } else {
                // Major success (3-5 rounds)
                return [
                    "success" => true,
                    "outcome_type" => "major_success", 
                    "points" => 3,
                    "rounds_taken" => $rounds_taken,
                    "final_roll" => $total,
                    "all_rolls" => $all_rolls,
                    "description" => "Major success! Rolled $total in $rounds_taken round(s)!"
                ];
            }
        }
    }
    
    // Failed to reach target in max attempts
    return [
        "success" => false,
        "outcome_type" => "failure",
        "points" => 0,
        "rounds_taken" => $rounds_taken,
        "final_roll" => 0,
        "all_rolls" => $all_rolls,
        "description" => "Failed to roll 18 or higher within 5 attempts"
    ];
}




    /**
     * Position selection action
     */
    public function actSelectPosition(string $position): void
    {
        $player_id = (int)$this->getCurrentPlayerId();
        
        // Validate position
        if (!in_array($position, ['offense', 'defense'])) {
            throw new \BgaUserException('Invalid position selection');
        }

        // Get both players
        $players = $this->getCollectionFromDB("SELECT player_id, player_name FROM player");
        $other_player_id = null;
        foreach ($players as $pid => $player) {
            if ($pid != $player_id) {
                $other_player_id = $pid;
                break;
            }
        }

        // Get current player name
        $player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $player_id");

        // Set positions
        $offense_player_id = $position === 'offense' ? $player_id : $other_player_id;
        $defense_player_id = $position === 'defense' ? $player_id : $other_player_id;
        
        $this->setGameStateValue("position_offense", $offense_player_id);
        $this->setGameStateValue("position_defense", $defense_player_id);

        // Notify all players about position selection
        $this->notifyAllPlayers("positionSelected", '${player_name} chooses ${position}. Match begins!', [
            "player_id" => $player_id,
            "player_name" => $player_name,
            "position" => ucfirst($position),
            "offense_player_id" => $offense_player_id,
            "defense_player_id" => $defense_player_id,
            "period" => 1,
            "round" => 1
        ]);

        $this->gamestate->nextState("positionSelected");
    }
    
	/**
	 * FIXED: Enhanced actChooseDie method to ensure proper data storage
	 */
	public function actChooseDie(string $die_choice): void
	{
		$player_id = (int)$this->getCurrentPlayerId();
		$state_name = $this->gamestate->state()['name'];
		
		$this->trace("actChooseDie: START - Player $player_id choosing $die_choice in state $state_name");
		
		// Validate die choice
		if (!in_array($die_choice, ['red', 'blue'])) {
			throw new \BgaUserException('Invalid die choice - must be red or blue');
		}

		// Store die choice FIRST
		$die_choice_numeric = $die_choice === 'red' ? 1 : 2;
		if ($state_name === 'firstPlayerChooseDie') {
			$this->setGameStateValue("first_player_die_choice", $die_choice_numeric);
			$this->trace("actChooseDie: Stored first_player_die_choice = $die_choice_numeric");
		} else if ($state_name === 'secondPlayerChooseDie') {
			$this->setGameStateValue("second_player_die_choice", $die_choice_numeric);
			$this->trace("actChooseDie: Stored second_player_die_choice = $die_choice_numeric");
		}

		// Roll the chosen die and get the actual value
		$die_value = 0;
		$die_face = 0;
		
		if ($die_choice === 'red') {
			$die_value = $this->rollRedDie();
			$die_face = $this->getGameStateValue("red_die");
			$this->trace("actChooseDie: Rolled red die - face=$die_face, value=$die_value");
		} else { // blue
			$die_value = $this->rollBlueDie();
			$die_face = $this->getGameStateValue("blue_die");
			$this->trace("actChooseDie: Rolled blue die - face=$die_face, value=$die_value");
		}

		// Store die value immediately after rolling
		if ($state_name === 'firstPlayerChooseDie') {
			$this->setGameStateValue("first_player_die_value", $die_value);
			$this->trace("actChooseDie: Stored first_player_die_value = $die_value");
		} else if ($state_name === 'secondPlayerChooseDie') {
			$this->setGameStateValue("second_player_die_value", $die_value);
			$this->trace("actChooseDie: Stored second_player_die_value = $die_value");
		}

		// Apply dice costs and rewards AFTER storing the values
		$this->applyDiceCosts($player_id, $die_choice);
		
		// FIXED: Get updated token count after applying costs
		$new_tokens = (int)$this->getUniqueValueFromDB("SELECT special_tokens FROM player WHERE player_id = $player_id");
		$new_conditioning = (int)$this->getUniqueValueFromDB("SELECT conditioning FROM player WHERE player_id = $player_id");
		
		$this->trace("actChooseDie: After costs - tokens=$new_tokens, conditioning=$new_conditioning");

		// Get player name and notify
		$player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = " . (int)$player_id);
		if (!$player_name) {
			$player_name = "Player $player_id";
		}

		$die_label = $die_choice === 'red' ? 'Red (STRENGTH)' : 'Blue (SPEED)';
		
		$this->notifyAllPlayers("playerChoseDie", '${player_name} chose ${die_label} and rolled: ${die_value}', [
			"player_id" => $player_id,
			"player_name" => $player_name,
			"die_choice" => $die_choice,
			"die_label" => $die_label,
			"die_face" => $die_face,
			"die_value" => $die_value,
			"new_tokens" => $new_tokens,          // FIXED: Include updated token count
			"new_conditioning" => $new_conditioning // FIXED: Include updated conditioning
		]);

		$this->gamestate->nextState("diceChosen");
	}

	// Add this method to your Game.php file (around line 300, after actChooseDie)

	/**
	 * NEW: Automatically roll dice based on card actions
	 */
	public function stRollDiceBasedOnCards(): void
	{
		$this->trace("stRollDiceBasedOnCards: START - Rolling dice based on card actions");
		
		// Get the cards played
		$first_card_id = $this->getGameStateValue("first_player_card");
		$second_card_id = $this->getGameStateValue("second_player_card");
		$first_player_id = (int)$this->getGameStateValue("first_player_id");
		$second_player_id = (int)$this->getGameStateValue("second_player_id");
		
		if (!$first_card_id || !$second_card_id || !$first_player_id || !$second_player_id) {
			throw new \BgaSystemException("Missing card/player data in stRollDiceBasedOnCards");
		}
		
		$first_card = self::$CARD_TYPES[$first_card_id];
		$second_card = self::$CARD_TYPES[$second_card_id];
		
		$this->trace("stRollDiceBasedOnCards: First player card action: " . $first_card['action']);
		$this->trace("stRollDiceBasedOnCards: Second player card action: " . $second_card['action']);
		
		// Determine and roll dice for each player
		$first_player_results = $this->rollDieForCard($first_player_id, $first_card);
		$second_player_results = $this->rollDieForCard($second_player_id, $second_card);
		
		// Store the results
		if ($first_player_results) {
			$this->setGameStateValue("first_player_die_choice", $first_player_results['die_choice']);
			$this->setGameStateValue("first_player_die_value", $first_player_results['die_value']);
		}
		
		if ($second_player_results) {
			$this->setGameStateValue("second_player_die_choice", $second_player_results['die_choice']);
			$this->setGameStateValue("second_player_die_value", $second_player_results['die_value']);
		}
		
		// Notify about dice results
		$this->notifyDiceResults($first_player_id, $first_player_results, $second_player_id, $second_player_results);
		
		// Check if any players need reroll options
		$this->checkForRerollOptions($first_player_id, $first_player_results, $second_player_id, $second_player_results);
	}

	// Add these 3 helper methods to your Game.php file (after the stRollDiceBasedOnCards method)

	/**
	 * NEW: Roll die for a specific card action
	 */
	private function rollDieForCard(int $player_id, array $card): ?array
	{
		$action = $card['action'];
		
		if ($action === 'roll_speed') {
			// Roll blue die
			$die_value = $this->rollBlueDie();
			$die_face = $this->getGameStateValue("blue_die");
			$die_choice = 2; // blue
			$die_type = 'blue';
			
			$this->trace("rollDieForCard: Player $player_id rolled blue die - face: $die_face, value: $die_value");
			
		} else if ($action === 'roll_strength') {
			// Roll red die
			$die_value = $this->rollRedDie();
			$die_face = $this->getGameStateValue("red_die");
			$die_choice = 1; // red
			$die_type = 'red';
			
			$this->trace("rollDieForCard: Player $player_id rolled red die - face: $die_face, value: $die_value");
			
		} else {
			// Card doesn't roll dice (stall, adrenaline, etc.)
			$this->trace("rollDieForCard: Player $player_id card has no die roll action: $action");
			return null;
		}
		
		// Apply dice costs immediately
		$this->applyDiceCosts($player_id, $die_type);
		
		return [
			'die_choice' => $die_choice,
			'die_value' => $die_value,
			'die_face' => $die_face,
			'die_type' => $die_type,
			'card_action' => $action
		];
	}

	/**
	 * NEW: Notify about dice roll results
	 */
	private function notifyDiceResults(int $first_player_id, ?array $first_results, int $second_player_id, ?array $second_results): void
	{
		$first_player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $first_player_id");
		$second_player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $second_player_id");
		
		$dice_summary = [];
		
		if ($first_results) {
			$dice_summary[] = [
				'player_id' => $first_player_id,
				'player_name' => $first_player_name,
				'die_type' => $first_results['die_type'],
				'die_face' => $first_results['die_face'],
				'die_value' => $first_results['die_value'],
				'card_action' => $first_results['card_action']
			];
		}
		
		if ($second_results) {
			$dice_summary[] = [
				'player_id' => $second_player_id,
				'player_name' => $second_player_name,
				'die_type' => $second_results['die_type'],
				'die_face' => $second_results['die_face'],
				'die_value' => $second_results['die_value'],
				'card_action' => $second_results['card_action']
			];
		}
		
		$this->notifyAllPlayers("diceRolledAutomatically", 'Dice rolled based on card actions', [
			'dice_results' => $dice_summary,
			'first_player_rolled' => $first_results !== null,
			'second_player_rolled' => $second_results !== null
		]);
	}

	/**
	 * NEW: Check if players need reroll options
	 */
	private function checkForRerollOptions(int $first_player_id, ?array $first_results, int $second_player_id, ?array $second_results): void
	{
		// For now, go to first player reroll if they rolled a die
		if ($first_results) {
			$this->gamestate->changeActivePlayer($first_player_id);
			$this->gamestate->nextState("firstPlayerReroll");
		} else if ($second_results) {
			$this->gamestate->changeActivePlayer($second_player_id);
			$this->gamestate->nextState("secondPlayerReroll");
		} else {
			// Neither player rolled dice, skip reroll phase
			$this->gamestate->nextState("noRerolls");
		}
	}



    /**
     * Updated reroll methods to use player's chosen die
     */
	/**
	 * Enhanced actRerollDice - undoes previous die effects and goes back to choice
	 */
	public function actRerollDice(): void
	{
		$player_id = (int)$this->getCurrentPlayerId();
		$state_name = $this->gamestate->state()['name'];
		
		$this->trace("actRerollDice: Player $player_id wants to reroll in state $state_name");

		// Check if player can afford reroll
		if (!$this->canPlayerReroll($player_id)) {
			throw new \BgaUserException("You need at least 1 token to reroll");
		}

		// Get the previous die choice and effects to undo them
		$previous_die_choice = 0;
		$previous_die_value = 0;
		
		if ($state_name === 'firstPlayerRerollOption') {
			$previous_die_choice = $this->getGameStateValue("first_player_die_choice");
			$previous_die_value = $this->getGameStateValue("first_player_die_value");
		} else if ($state_name === 'secondPlayerRerollOption') {
			$previous_die_choice = $this->getGameStateValue("second_player_die_choice");
			$previous_die_value = $this->getGameStateValue("second_player_die_value");
		}
		
		$previous_die_type = $previous_die_choice == 1 ? 'red' : 'blue';
		
		$this->trace("actRerollDice: Undoing previous $previous_die_type die (value: $previous_die_value)");

		// STEP 1: Deduct 1 token for the reroll cost
		$this->DbQuery("UPDATE player SET special_tokens = special_tokens - 1 WHERE player_id = $player_id");
		
		// STEP 2: Undo the previous die's conditioning/token effects
		$this->undoPreviousDieEffects($player_id, $previous_die_type);
		
		// STEP 3: Undo any offense adjustments from the previous die
		if ($previous_die_value != 0) {
			$this->DbQuery("UPDATE player SET offense = offense - $previous_die_value WHERE player_id = $player_id");
			$this->trace("actRerollDice: Undid $previous_die_value offense adjustment");
		}
		
		// STEP 4: Clear the previous die choice and value
		if ($state_name === 'firstPlayerRerollOption') {
			$this->setGameStateValue("first_player_die_choice", 0);
			$this->setGameStateValue("first_player_die_value", 0);
		} else if ($state_name === 'secondPlayerRerollOption') {
			$this->setGameStateValue("second_player_die_choice", 0);
			$this->setGameStateValue("second_player_die_value", 0);
		}

		// Get updated resources for notification
		$new_tokens = (int)$this->getUniqueValueFromDB("SELECT special_tokens FROM player WHERE player_id = $player_id");
		$new_conditioning = (int)$this->getUniqueValueFromDB("SELECT conditioning FROM player WHERE player_id = $player_id");
		$new_offense = (int)$this->getUniqueValueFromDB("SELECT offense FROM player WHERE player_id = $player_id");
		
		// Get player name
		$player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = " . (int)$player_id);
		if (!$player_name) {
			$player_name = "Player $player_id";
		}

		$this->notifyAllPlayers("playerRerollComplete", '${player_name} spent 1 token to reroll - all effects undone, choosing die again', [
			"player_id" => $player_id,
			"player_name" => $player_name,
			"previous_die_type" => $previous_die_type,
			"previous_die_value" => $previous_die_value,
			"new_tokens" => $new_tokens,
			"new_conditioning" => $new_conditioning,
			"new_offense" => $new_offense,
			"reroll_cost" => 1
		]);

		$this->gamestate->nextState("reroll");
	}

	/**
	 * NEW: Undo the conditioning and token effects of the previous die choice
	 */
	private function undoPreviousDieEffects(int $player_id, string $previous_die_type): void
	{
		$this->trace("undoPreviousDieEffects: Undoing $previous_die_type die effects for player $player_id");
		
		if ($previous_die_type === 'red') {
			// Red die: originally cost 3 conditioning and gave 1 token
			// So we need to: add back 3 conditioning, remove 1 token
			$this->DbQuery("UPDATE player SET conditioning = conditioning + 3, special_tokens = special_tokens - 1 WHERE player_id = $player_id");
			$this->trace("undoPreviousDieEffects: Undid red die - added 3 conditioning, removed 1 token");
		} else if ($previous_die_type === 'blue') {
			// Blue die: originally cost 2 conditioning and gave 2 tokens  
			// So we need to: add back 2 conditioning, remove 2 tokens
			$this->DbQuery("UPDATE player SET conditioning = conditioning + 2, special_tokens = special_tokens - 2 WHERE player_id = $player_id");
			$this->trace("undoPreviousDieEffects: Undid blue die - added 2 conditioning, removed 2 tokens");
		}
	}

    /**
     * Updated reroll argument method - IMPROVED with error handling
     */

	/**
	 * Enhanced argRerollOption with reroll cost warning
	 */
	public function argRerollOption(): array
	{
		$player_id = (int)$this->getActivePlayerId();
		$state_name = $this->gamestate->state()['name'];
		
		// Get die choice and value data
		$die_choice_value = 0;
		$die_value = 0;
		
		if ($state_name === 'firstPlayerRerollOption') {
			$die_choice_value = $this->getGameStateValue("first_player_die_choice");
			$die_value = $this->getGameStateValue("first_player_die_value");
		} else if ($state_name === 'secondPlayerRerollOption') {
			$die_choice_value = $this->getGameStateValue("second_player_die_choice");
			$die_value = $this->getGameStateValue("second_player_die_value");
		}
		
		$die_type = $die_choice_value == 1 ? 'red' : 'blue';
		
		// Get current player resources
		$player_data = $this->getObjectFromDB("SELECT conditioning, special_tokens FROM player WHERE player_id = $player_id");
		$current_tokens = $player_data ? (int)$player_data['special_tokens'] : 0;
		$current_conditioning = $player_data ? (int)$player_data['conditioning'] : 0;
		
		return [
			"can_reroll" => $current_tokens >= 1,
			"die_type" => $die_type,
			"die_value" => $die_value,
			"current_tokens" => $current_tokens,
			"current_conditioning" => $current_conditioning,
			"reroll_explanation" => "Reroll will undo all effects and let you choose a die again (costs 1 token)"
		];
	}
    /**
     * Fixed actPlayCard - consistent use of global variables
     */
    public function actPlayCard(int $card_id): void
    {
        $player_id = (int)$this->getCurrentPlayerId();
        $state_name = $this->gamestate->state()['name'];

        $this->trace("actPlayCard: Player $player_id playing card $card_id in state $state_name");

        // Validate that we have a valid player ID
        if ($player_id <= 0) {
            $this->trace("actPlayCard: ERROR - Invalid player ID: $player_id");
            throw new \BgaUserException('Invalid player - please refresh the page');
        }

        // Validate card choice using the same logic as argPlayerTurn
        $args = $this->argPlayerTurn();
        $playableCardsIds = $args['playableCardsIds'];
        
        $this->trace("actPlayCard: Playable cards for player $player_id: " . implode(', ', $playableCardsIds));
        
        if (!in_array($card_id, $playableCardsIds)) {
            $this->trace("actPlayCard: ERROR - Card $card_id not in playable list");
            throw new \BgaUserException('Invalid card choice - you cannot afford this card or it is not available in your position');
        }

        // Double-check affordability
        if (!$this->canAffordCard($player_id, $card_id)) {
            $this->trace("actPlayCard: ERROR - Player $player_id cannot afford card $card_id");
            throw new \BgaUserException('You do not have enough conditioning or special tokens to play this card');
        }

        $card_name = self::$CARD_TYPES[$card_id]['card_name'];
        
        // Get player name with proper casting and validation
        $player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = " . (int)$player_id);
        if (!$player_name) {
            $this->trace("actPlayCard: WARNING - Could not find name for player $player_id, using fallback");
            $player_name = "Player $player_id";
        }

        $this->trace("actPlayCard: Player $player_id ($player_name) successfully playing card $card_id ($card_name)");

        if ($state_name === 'firstPlayerTurn') {
            // Store first player's card in global variables
            $this->setGameStateValue("first_player_id", $player_id);
            $this->setGameStateValue("first_player_card", $card_id);            
            $this->trace("actPlayCard: Stored first player card, transitioning to second player");
            
            // Notify that first player played (but don't reveal the card)
            $this->notifyAllPlayers("firstCardPlayed", '${player_name} has played a card', [
                "player_id" => $player_id,
                "player_name" => $player_name,
            ]);

            $this->gamestate->nextState("cardPlayed");
            
        } else if ($state_name === 'secondPlayerTurn') {
            // Store second player's card in global variables
            $this->setGameStateValue("second_player_id", $player_id);
            $this->setGameStateValue("second_player_card", $card_id);
            
            $this->trace("actPlayCard: Stored second player card, transitioning to reveal");
            
            // Notify that second player played (but don't reveal yet)
            $this->notifyAllPlayers("secondCardPlayed", '${player_name} has played a card', [
                "player_id" => $player_id,
                "player_name" => $player_name,
            ]);

            $this->gamestate->nextState("cardPlayed");
        } else {
            $this->trace("actPlayCard: ERROR - Unexpected state $state_name");
            throw new \BgaUserException("Cannot play card in current game state");
        }
    }

    /**
     * NEW: Player chooses to keep their die result
     */
    public function actKeepDice(): void
    {
        $player_id = (int)$this->getCurrentPlayerId();
        $state_name = $this->gamestate->state()['name'];
        
        $this->trace("actKeepDice: Player $player_id keeps dice in state $state_name");

        // Get player name
        $player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = " . (int)$player_id);
        if (!$player_name) {
            $player_name = "Player $player_id";
        }

        $this->notifyAllPlayers("playerKeepDice", '${player_name} keeps their dice result', [
            "player_id" => $player_id,
            "player_name" => $player_name,
        ]);

        $this->gamestate->nextState("keep");
    }

    /**
     * Populate wrestlers table from material.inc.php data
     */
    private function populateWrestlersTable(): void
    {
        $this->trace("populateWrestlersTable: START");
        
        // Clear existing data
        $this->DbQuery("DELETE FROM wrestlers");
        
        // Insert wrestlers from material data
        foreach (self::$WRESTLERS as $wrestler_id => $wrestler) {
            $name = addslashes($wrestler['name']);
            $trademark = addslashes($wrestler['trademark']);
            $special_cards = addslashes(implode(',', $wrestler['special_cards']));
            
            $sql = "INSERT INTO wrestlers 
                    (wrestler_id, wrestler_name, conditioning_p1, conditioning_p2, conditioning_p3, 
                     offense, defense, top, bottom, special_tokens, trademark, special_cards) 
                    VALUES 
                    ($wrestler_id, '$name', {$wrestler['conditioning_p1']}, {$wrestler['conditioning_p2']}, {$wrestler['conditioning_p3']}, 
                     {$wrestler['offense']}, {$wrestler['defense']}, {$wrestler['top']}, {$wrestler['bottom']}, 
                     {$wrestler['special_tokens']}, '$trademark', '$special_cards')";
            
            $this->DbQuery($sql);
            $this->trace("populateWrestlersTable: Inserted wrestler $wrestler_id - {$wrestler['name']}");
        }
        
        $this->trace("populateWrestlersTable: COMPLETE - Inserted " . count(self::$WRESTLERS) . " wrestlers");
    }

    /**
     * Updated stRevealCards with direct data access
     */
	public function stRevealCards(): void
	{
		// Get the data from global variables and cast to int
		$first_player_id = (int)$this->getGameStateValue("first_player_id");  // CAST TO INT
		$second_player_id = (int)$this->getGameStateValue("second_player_id"); // CAST TO INT
		$first_card = $this->getGameStateValue("first_player_card");
		$second_card = $this->getGameStateValue("second_player_card");

		$this->trace("stRevealCards: first_player=$first_player_id, first_card=$first_card, second_player=$second_player_id, second_card=$second_card");

		// Validate that we have the data
		if (!$first_card || !$second_card || !$first_player_id || !$second_player_id) {
			$this->trace("stRevealCards: ERROR - Missing card data");
			throw new \BgaSystemException("Missing card data in stRevealCards");
		}

		// Get player names with proper casting
		$first_player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = " . (int)$first_player_id);
		$second_player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = " . (int)$second_player_id);
		
		// Fallback names if queries fail
		if (!$first_player_name) {
			$first_player_name = "Player $first_player_id";
		}
		if (!$second_player_name) {
			$second_player_name = "Player $second_player_id";
		}
		
		$first_card_name = self::$CARD_TYPES[$first_card]['card_name'];
		$second_card_name = self::$CARD_TYPES[$second_card]['card_name'];

		$this->trace("stRevealCards: Revealing cards - $first_player_name played $first_card_name, $second_player_name played $second_card_name");

		// Reveal both cards
		$this->notifyAllPlayers("cardsRevealed", 'Cards revealed: ${first_player_name} played ${first_card_name}, ${second_player_name} played ${second_card_name}', [
			"first_player_id" => $first_player_id,
			"first_player_name" => $first_player_name,
			"first_card_id" => $first_card,
			"first_card_name" => $first_card_name,
			"second_player_id" => $second_player_id,
			"second_player_name" => $second_player_name,
			"second_card_id" => $second_card,
			"second_card_name" => $second_card_name,
		]);

		// Clean up - reset the temporary score storage
		$this->DbQuery("UPDATE player SET player_score = 0 WHERE player_id = " . (int)$first_player_id);

		$this->gamestate->nextState("resolve");
	}
    
    /**
     * Step 1: Adjust conditioning based on cards played - FIXED
     */
	// 4. FIX: Update conditioning notification to include token updates
	public function stAdjustConditioning(): void
	{
		// FIXED: Use global variables and cast to int
		$first_card_id = $this->getGameStateValue("first_player_card");
		$second_card_id = $this->getGameStateValue("second_player_card");
		$first_player_id = (int)$this->getGameStateValue("first_player_id");
		$second_player_id = (int)$this->getGameStateValue("second_player_id");

		$this->trace("stAdjustConditioning: first_card=$first_card_id, second_card=$second_card_id, first_player=$first_player_id, second_player=$second_player_id");

		// Validate we have the data
		if (!$first_card_id || !$second_card_id || !$first_player_id || !$second_player_id) {
			$this->trace("stAdjustConditioning: ERROR - Missing round state data");
			throw new \BgaSystemException("Missing round state data in stAdjustConditioning");
		}

		$first_card = self::$CARD_TYPES[$first_card_id];
		$second_card = self::$CARD_TYPES[$second_card_id];

		// Deduct conditioning costs
		$first_cost = $first_card['conditioning_cost'];
		$second_cost = $second_card['conditioning_cost'];

		$this->trace("stAdjustConditioning: Deducting conditioning - Player $first_player_id: $first_cost, Player $second_player_id: $second_cost");

		$this->DbQuery("UPDATE player SET conditioning = conditioning - $first_cost WHERE player_id = $first_player_id");
		$this->DbQuery("UPDATE player SET conditioning = conditioning - $second_cost WHERE player_id = $second_player_id");

		// Get updated conditioning values
		$first_conditioning = (int)$this->getUniqueValueFromDB("SELECT conditioning FROM player WHERE player_id = $first_player_id");
		$second_conditioning = (int)$this->getUniqueValueFromDB("SELECT conditioning FROM player WHERE player_id = $second_player_id");

		$this->notifyAllPlayers("conditioningAdjusted", 'Conditioning adjusted', [
			"updates" => [
				$first_player_id => ["conditioning" => $first_conditioning, "cost" => $first_cost],
				$second_player_id => ["conditioning" => $second_conditioning, "cost" => $second_cost]
			]
		]);

		$this->gamestate->nextState("rollDice");
	}

    /**
     * stApplyEffects - Apply each player's chosen die result to their offense
     */
	public function stApplyEffects(): void
	{
		// Get the data from global variables
		$first_card_id = $this->getGameStateValue("first_player_card");
		$second_card_id = $this->getGameStateValue("second_player_card");
		$first_player_id = (int)$this->getGameStateValue("first_player_id");
		$second_player_id = (int)$this->getGameStateValue("second_player_id");

		// Validate that we have the data
		if (!$first_card_id || !$second_card_id || !$first_player_id || !$second_player_id) {
			$this->trace("stApplyEffects: ERROR - Missing round state data");
			throw new \BgaSystemException("Missing round state data in stApplyEffects");
		}

		// Get die choices and values for each player
		$first_die_choice = $this->getGameStateValue("first_player_die_choice");
		$second_die_choice = $this->getGameStateValue("second_player_die_choice");
		$first_die_value = $this->getGameStateValue("first_player_die_value");
		$second_die_value = $this->getGameStateValue("second_player_die_value");

		$first_die_type = $first_die_choice == 1 ? 'red' : 'blue';
		$second_die_type = $second_die_choice == 1 ? 'red' : 'blue';

		$this->trace("stApplyEffects: Player $first_player_id chose $first_die_type = $first_die_value, Player $second_player_id chose $second_die_type = $second_die_value");

		$first_card = self::$CARD_TYPES[$first_card_id];
		$second_card = self::$CARD_TYPES[$second_card_id];

		// Get wrestler data
		$first_wrestler_id = (int)$this->getUniqueValueFromDB("SELECT wrestler_id FROM player WHERE player_id = " . (int)$first_player_id);
		$second_wrestler_id = (int)$this->getUniqueValueFromDB("SELECT wrestler_id FROM player WHERE player_id = " . (int)$second_player_id);
		
		if (!$first_wrestler_id || !$second_wrestler_id) {
			throw new \BgaSystemException("Could not find wrestler IDs");
		}
		
		$first_wrestler = self::$WRESTLERS[$first_wrestler_id];
		$second_wrestler = self::$WRESTLERS[$second_wrestler_id];

		// APPLY DICE RESULTS TO OFFENSE STATS
		$this->applyDiceToOffense($first_player_id, (int)$first_die_value);
		$this->applyDiceToOffense($second_player_id, (int)$second_die_value);

		// Get updated offense values for notification
		$first_new_offense = $this->getUniqueValueFromDB("SELECT offense FROM player WHERE player_id = $first_player_id");
		$second_new_offense = $this->getUniqueValueFromDB("SELECT offense FROM player WHERE player_id = $second_player_id");

		// Build effects description
		$effects_applied = [];
		
		// Dice effects
		$first_die_label = $first_die_type === 'red' ? 'Red (STRENGTH)' : 'Blue (SPEED)';
		$second_die_label = $second_die_type === 'red' ? 'Red (STRENGTH)' : 'Blue (SPEED)';
		
		if ($first_die_value != 0) {
			$effects_applied[] = "{$first_wrestler['name']} gained $first_die_value offense from $first_die_label die (new total: $first_new_offense)";
		} else {
			$effects_applied[] = "{$first_wrestler['name']}'s offense unchanged from $first_die_label die (total: $first_new_offense)";
		}
		
		if ($second_die_value != 0) {
			$effects_applied[] = "{$second_wrestler['name']} gained $second_die_value offense from $second_die_label die (new total: $second_new_offense)";
		} else {
			$effects_applied[] = "{$second_wrestler['name']}'s offense unchanged from $second_die_label die (total: $second_new_offense)";
		}
		
		// Basic card resolution logic
		if ($first_card['scoring']) {
			$effects_applied[] = "{$first_wrestler['name']}'s {$first_card['card_name']} has scoring potential";
		}
		
		if ($second_card['scoring']) {
			$effects_applied[] = "{$second_wrestler['name']}'s {$second_card['card_name']} has scoring potential";
		}

		// Apply trademark effects (placeholder)
		$effects_applied[] = "{$first_wrestler['name']} trademark: " . $first_wrestler['trademark'];
		$effects_applied[] = "{$second_wrestler['name']} trademark: " . $second_wrestler['trademark'];

		$this->trace("stApplyEffects: Effects applied: " . implode(', ', $effects_applied));

		$this->notifyAllPlayers("effectsApplied", 'Card and dice effects applied', [
			"effects" => $effects_applied,
			"first_die_choice" => $first_die_type,
			"second_die_choice" => $second_die_type,
			"first_die_value" => $first_die_value,
			"second_die_value" => $second_die_value,
			"first_card" => $first_card['card_name'],
			"second_card" => $second_card['card_name'],
			"offense_updates" => [
				$first_player_id => $first_new_offense,
				$second_player_id => $second_new_offense
			]
		]);

		$this->gamestate->nextState("handleTokens");
	}

	// 2. UPDATED: stStatComparison method with simple momentum tracking
	public function stStatComparison(): void
	{
		$this->trace("stStatComparison: START - Comparing offensive and defensive stats");
		
		// Get current round data
		$first_card_id = $this->getGameStateValue("first_player_card");
		$second_card_id = $this->getGameStateValue("second_player_card");
		$first_player_id = (int)$this->getGameStateValue("first_player_id");
		$second_player_id = (int)$this->getGameStateValue("second_player_id");
		
		// Get current positions
		$offense_player_id = (int)$this->getGameStateValue("position_offense");
		$defense_player_id = (int)$this->getGameStateValue("position_defense");
		
		$this->trace("stStatComparison: Offense player: $offense_player_id, Defense player: $defense_player_id");
		
		// Get current stats for both players
		$offense_stats = $this->getObjectFromDB("SELECT offense, defense FROM player WHERE player_id = $offense_player_id");
		$defense_stats = $this->getObjectFromDB("SELECT offense, defense FROM player WHERE player_id = $defense_player_id");
		
		if (!$offense_stats || !$defense_stats) {
			throw new \BgaSystemException("Could not retrieve player stats for comparison");
		}
		
		$offense_value = (int)$offense_stats['offense'];
		$defense_value = (int)$defense_stats['defense'];
		
		$this->trace("stStatComparison: Offense stat: $offense_value vs Defense stat: $defense_value");
		
		// Determine which card the offense player played
		$offense_card_id = null;
		$offense_card_scoring = false;
		
		if ($first_player_id == $offense_player_id) {
			$offense_card_id = $first_card_id;
		} else if ($second_player_id == $offense_player_id) {
			$offense_card_id = $second_card_id;
		}
		
		if ($offense_card_id) {
			$offense_card = self::$CARD_TYPES[$offense_card_id];
			$offense_card_scoring = $offense_card['scoring'];
			$this->trace("stStatComparison: Offense player played card {$offense_card['card_name']}, scoring: " . ($offense_card_scoring ? 'YES' : 'NO'));
		}
		
		// Get player names for notifications
		$offense_player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $offense_player_id");
		$defense_player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $defense_player_id");
		
		// Perform the stat comparison and handle momentum
		$comparison_result = '';
		$next_state = '';
		
		if ($offense_value > $defense_value) {
			// Offense wins - clear momentum
			$this->trace("stStatComparison: Offense wins ($offense_value > $defense_value)");
			$comparison_result = "Offense succeeds! {$offense_player_name}'s offense ({$offense_value}) beats {$defense_player_name}'s defense ({$defense_value})";
			
			// Clear momentum since offense succeeded
			$this->setGameStateValue("momentum_player", 0);
			
			if ($offense_card_scoring) {
				$this->trace("stStatComparison: Scoring card played - will draw scramble card");
				$comparison_result .= " AND played a scoring card! Drawing scramble card...";
				
				// Set the offense player as active for scramble resolution
				$this->gamestate->changeActivePlayer($offense_player_id);
				$next_state = 'drawScramble';
			} else {
				$this->trace("stStatComparison: Non-scoring card - round ends normally");
				$next_state = 'nextRound';
			}
			
		} else if ($offense_value == $defense_value) {
			// Tie - second player gains momentum
			$this->trace("stStatComparison: Stats tied ($offense_value = $defense_value) - second player gains momentum");
			
			$second_player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $second_player_id");
			
			$comparison_result = "Stats tied! {$offense_player_name}'s offense ({$offense_value}) equals {$defense_player_name}'s defense ({$defense_value}). {$second_player_name} gains momentum for next round!";
			
			// Store momentum for second player
			$this->setGameStateValue("momentum_player", $second_player_id);
			
			$next_state = 'nextRound';
			
		} else {
			// Defense wins - clear momentum
			$this->trace("stStatComparison: Defense wins ($offense_value < $defense_value)");
			$comparison_result = "Defense succeeds! {$defense_player_name}'s defense ({$defense_value}) stops {$offense_player_name}'s offense ({$offense_value}). Round ends.";
			
			// Clear momentum since defense succeeded
			$this->setGameStateValue("momentum_player", 0);
			
			$next_state = 'nextRound';
		}
		
		// Notify all players of the comparison result
		$this->notifyAllPlayers("statComparison", '${result}', [
			"result" => $comparison_result,
			"offense_value" => $offense_value,
			"defense_value" => $defense_value,
			"offense_player_id" => $offense_player_id,
			"defense_player_id" => $defense_player_id,
			"offense_player_name" => $offense_player_name,
			"defense_player_name" => $defense_player_name,
			"scoring_card_played" => $offense_card_scoring,
			"comparison_type" => $offense_value > $defense_value ? 'offense_wins' : ($offense_value == $defense_value ? 'tie' : 'defense_wins'),
			"momentum_player_id" => $offense_value == $defense_value ? $second_player_id : 0
		]);
		
		$this->gamestate->nextState($next_state);
	}



	// 4. NEW: Method to draw a scramble card
	private function drawScrambleCard(): array
	{
		// Define scramble cards (you can move this to material.inc.php later)
		$scramble_cards = [
			1 => [
				"name" => "Takedown",
				"description" => "Score 2 points and switch to top position",
				"effect" => "score_points",
				"points" => 2,
				"position_change" => "top"
			],
			2 => [
				"name" => "Escape",
				"description" => "Score 1 point and switch to neutral",
				"effect" => "score_points", 
				"points" => 1,
				"position_change" => "neutral"
			],
			3 => [
				"name" => "Reversal",
				"description" => "Score 2 points and reverse positions",
				"effect" => "score_points",
				"points" => 2,
				"position_change" => "reverse"
			],
			4 => [
				"name" => "Near Fall",
				"description" => "Score 2 points and maintain top position",
				"effect" => "score_points",
				"points" => 2,
				"position_change" => "maintain"
			],
			5 => [
				"name" => "Stalemate",
				"description" => "No points scored, return to neutral",
				"effect" => "no_score",
				"points" => 0,
				"position_change" => "neutral"
			],
			6 => [
				"name" => "Penalty",
				"description" => "Opponent scores 1 point due to penalty",
				"effect" => "opponent_score",
				"points" => 1,
				"position_change" => "maintain"
			]
		];
		
		// Randomly select a scramble card
		$card_id = bga_rand(1, count($scramble_cards));
		return $scramble_cards[$card_id];
	}

	// 5. NEW: Method to apply scramble card effects
	private function applyScrambleCardEffects(array $scramble_card, int $player_id): void
	{
		$this->trace("applyScrambleCardEffects: Applying {$scramble_card['name']} for player $player_id");
		
		$effects_applied = [];
		
		switch ($scramble_card['effect']) {
			case 'score_points':
				// Award points to the player
				$this->DbQuery("UPDATE player SET player_score = player_score + {$scramble_card['points']} WHERE player_id = $player_id");
				$effects_applied[] = "Scored {$scramble_card['points']} points";
				break;
				
			case 'opponent_score':
				// Award points to opponent
				$offense_player_id = (int)$this->getGameStateValue("position_offense");
				$defense_player_id = (int)$this->getGameStateValue("position_defense");
				$opponent_id = $player_id == $offense_player_id ? $defense_player_id : $offense_player_id;
				
				$this->DbQuery("UPDATE player SET player_score = player_score + {$scramble_card['points']} WHERE player_id = $opponent_id");
				$opponent_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $opponent_id");
				$effects_applied[] = "{$opponent_name} scored {$scramble_card['points']} points due to penalty";
				break;
				
			case 'no_score':
				$effects_applied[] = "No points scored";
				break;
		}
		
		// Handle position changes
		if (isset($scramble_card['position_change'])) {
			$position_effect = $this->applyPositionChange($scramble_card['position_change'], $player_id);
			if ($position_effect) {
				$effects_applied[] = $position_effect;
			}
		}
		
		// Notify about scramble card effects
		$this->notifyAllPlayers("scrambleCardResolved", 'Scramble card resolved: ${effects}', [
			"effects" => $effects_applied,
			"card_name" => $scramble_card['name']
		]);
	}

	// 6. NEW: Method to handle position changes from scramble cards
	private function applyPositionChange(string $position_change, int $player_id): ?string
	{
		$offense_player_id = (int)$this->getGameStateValue("position_offense");
		$defense_player_id = (int)$this->getGameStateValue("position_defense");
		
		switch ($position_change) {
			case 'top':
				// Player goes to top, opponent to bottom
				$this->setGameStateValue("position_top", $player_id);
				$this->setGameStateValue("position_bottom", $player_id == $offense_player_id ? $defense_player_id : $offense_player_id);
				return "Position changed to top/bottom";
				
			case 'neutral':
				// Both players return to neutral (offense/defense)
				return "Returned to neutral position";
				
			case 'reverse':
				// Reverse current positions
				$this->setGameStateValue("position_offense", $defense_player_id);
				$this->setGameStateValue("position_defense", $offense_player_id);
				return "Positions reversed";
				
			case 'maintain':
				// Keep current positions
				return "Positions maintained";
				
			default:
				return null;
		}
	}




	// 2. FIX: stHandleTokens method - cast player IDs to int
	public function stHandleTokens(): void
	{
		// FIXED: Use global variables and cast to int
		$first_card_id = $this->getGameStateValue("first_player_card");
		$second_card_id = $this->getGameStateValue("second_player_card");
		$first_player_id = (int)$this->getGameStateValue("first_player_id");  // CAST TO INT
		$second_player_id = (int)$this->getGameStateValue("second_player_id"); // CAST TO INT

		$this->trace("stHandleTokens: first_card=$first_card_id, second_card=$second_card_id, first_player=$first_player_id, second_player=$second_player_id");

		// Validate we have the data
		if (!$first_card_id || !$second_card_id || !$first_player_id || !$second_player_id) {
			$this->trace("stHandleTokens: ERROR - Missing round state data");
			throw new \BgaSystemException("Missing round state data in stHandleTokens");
		}

		$first_card = self::$CARD_TYPES[$first_card_id];
		$second_card = self::$CARD_TYPES[$second_card_id];

		// Deduct special tokens for cards that require them
		$first_token_cost = $first_card['special_tokens'];
		$second_token_cost = $second_card['special_tokens'];

		$this->trace("stHandleTokens: Token costs - Player $first_player_id: $first_token_cost, Player $second_player_id: $second_token_cost");

		if ($first_token_cost > 0) {
			$this->DbQuery("UPDATE player SET special_tokens = special_tokens - $first_token_cost WHERE player_id = $first_player_id");
		}

		if ($second_token_cost > 0) {
			$this->DbQuery("UPDATE player SET special_tokens = special_tokens - $second_token_cost WHERE player_id = $second_player_id");
		}

		// Get updated token values
		$first_tokens = $this->getUniqueValueFromDB("SELECT special_tokens FROM player WHERE player_id = $first_player_id");
		$second_tokens = $this->getUniqueValueFromDB("SELECT special_tokens FROM player WHERE player_id = $second_player_id");

		$this->notifyAllPlayers("tokensHandled", 'Special tokens updated', [
			"updates" => [
				$first_player_id => ["special_tokens" => $first_tokens, "cost" => $first_token_cost],
				$second_player_id => ["special_tokens" => $second_tokens, "cost" => $second_token_cost]
			]
		]);

		$this->gamestate->nextState("statComparison");
	}

    
    /**
     * Roll the 8-sided red die (STRENGTH)
     * Values: -2, -2, 0, 0, 1, 2, 3, 3
     */
    private function rollRedDie(): int
    {
        $red_die_values = [-2, -2, 0, 0, 1, 2, 3, 3];
        $die_face = bga_rand(1, 8);
        $die_value = $red_die_values[$die_face - 1];
        
        $this->trace("rollRedDie: Face $die_face = Value $die_value");
        
        // Store both the face and the value
        $this->setGameStateValue("red_die", $die_face);
        
        return $die_value;
    }

    /**
     * Roll the 8-sided blue die (SPEED) 
     * Values: -1, -1, 0, 0, 1, 1, 2, 2
     */
    private function rollBlueDie(): int
    {
        $blue_die_values = [-1, -1, 0, 0, 1, 1, 2, 2];
        $die_face = bga_rand(1, 8);
        $die_value = $blue_die_values[$die_face - 1];
        
        $this->trace("rollBlueDie: Face $die_face = Value $die_value");
        
        // Store both the face and the value
        $this->setGameStateValue("blue_die", $die_face);
        
        return $die_value;
    }

    /**
     * Apply dice costs and token rewards to player
     */
	/**
	 * FIXED: Enhanced applyDiceCosts method with better logging
	 */
	private function applyDiceCosts(int $player_id, string $die_type): void
	{
		$this->trace("applyDiceCosts: START - Player $player_id chose $die_type die");
		
		// Get current values before applying costs
		$before_conditioning = (int)$this->getUniqueValueFromDB("SELECT conditioning FROM player WHERE player_id = $player_id");
		$before_tokens = (int)$this->getUniqueValueFromDB("SELECT special_tokens FROM player WHERE player_id = $player_id");
		
		if ($die_type === 'red') {
			// Red die: costs 3 conditioning, gain 1 token
			$this->DbQuery("UPDATE player SET conditioning = conditioning - 3, special_tokens = special_tokens + 1 WHERE player_id = $player_id");
			$conditioning_cost = 3;
			$token_gain = 1;
		} else if ($die_type === 'blue') {
			// Blue die: costs 2 conditioning, gain 2 tokens
			$this->DbQuery("UPDATE player SET conditioning = conditioning - 2, special_tokens = special_tokens + 2 WHERE player_id = $player_id");
			$conditioning_cost = 2;
			$token_gain = 2;
		} else {
			$this->trace("applyDiceCosts: ERROR - Invalid die type: $die_type");
			return;
		}
		
		// Get values after applying costs
		$after_conditioning = (int)$this->getUniqueValueFromDB("SELECT conditioning FROM player WHERE player_id = $player_id");
		$after_tokens = (int)$this->getUniqueValueFromDB("SELECT special_tokens FROM player WHERE player_id = $player_id");
		
		$this->trace("applyDiceCosts: Player $player_id - $die_type die");
		$this->trace("applyDiceCosts: Conditioning: $before_conditioning -> $after_conditioning (cost: $conditioning_cost)");
		$this->trace("applyDiceCosts: Tokens: $before_tokens -> $after_tokens (gain: $token_gain)");
	}

    /**
     * Apply dice result to player's offense stat
     */
	// 4. FIX: applyDiceToOffense method - ensure proper typing
	private function applyDiceToOffense(int $player_id, int $dice_total): void
	{
		$this->trace("applyDiceToOffense: Player $player_id getting $dice_total offense adjustment");
		
		if ($dice_total != 0) {
			$this->DbQuery("UPDATE player SET offense = offense + $dice_total WHERE player_id = $player_id");
			
			// Get updated offense value
			$new_offense = $this->getUniqueValueFromDB("SELECT offense FROM player WHERE player_id = $player_id");
			$this->trace("applyDiceToOffense: Player $player_id new offense: $new_offense");
		}
	}


    /**
     * Check if player can afford to reroll (needs 1+ tokens)
     */
	// 6. FIX: canPlayerReroll method - ensure proper typing
	private function canPlayerReroll(int $player_id): bool
	{
		$tokens = (int)$this->getUniqueValueFromDB("SELECT special_tokens FROM player WHERE player_id = $player_id");
		return $tokens >= 1;
	}

    /**
     * Determine next round/period
     */
	// 5. UPDATED: stNextRound method to clear round state but preserve momentum
	public function stNextRound(): void
	{
		// Get momentum before clearing other state
		$momentum_player = (int)$this->getGameStateValue("momentum_player");
		
		// Clear round state but keep momentum
		$this->setGameStateValue("first_player_card", 0);
		$this->setGameStateValue("second_player_card", 0);
		$this->setGameStateValue("first_player_id", 0);
		$this->setGameStateValue("second_player_id", 0);
		
		// Clear die choice state
		$this->setGameStateValue("first_player_die_choice", 0);
		$this->setGameStateValue("second_player_die_choice", 0);
		$this->setGameStateValue("first_player_die_value", 0);
		$this->setGameStateValue("second_player_die_value", 0);

		// Increment round
		$current_round = $this->getGameStateValue("current_round");
		$current_period = $this->getGameStateValue("current_period");
		
		$current_round++;
		
		// Check if period should advance
		$rounds_per_period = [1 => 9, 2 => 6, 3 => 6];
		if ($current_round > $rounds_per_period[$current_period]) {
			$current_period++;
			$current_round = 1;
			
			// Clear momentum at start of new period
			$this->setGameStateValue("momentum_player", 0);
			$momentum_player = 0;
			
			if ($current_period > 3) {
				// Game ends
				$this->gamestate->nextState("endGame");
				return;
			}
		}
		
		$this->setGameStateValue("current_round", $current_round);
		$this->setGameStateValue("current_period", $current_period);

		// Include momentum info in notification
		$momentum_info = '';
		if ($momentum_player > 0) {
			$momentum_player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $momentum_player");
			$momentum_info = " ({$momentum_player_name} has momentum)";
		}

		$this->notifyAllPlayers("newRound", 'Period ${period}, Round ${round}${momentum_info}', [
			"period" => $current_period,
			"round" => $current_round,
			"momentum_info" => $momentum_info,
			"momentum_player" => $momentum_player
		]);

		$this->gamestate->nextState("setNextPlayer");
	}

    /**
     * Set the first player for the round - IMPROVED with debugging
     */
	// 3. UPDATED: stSetFirstPlayer method to check for momentum
	public function stSetFirstPlayer(): void
	{
		$this->trace("stSetFirstPlayer: START");
		
		// Check if anyone has momentum
		$momentum_player = (int)$this->getGameStateValue("momentum_player");
		
		if ($momentum_player > 0) {
			// Player with momentum goes first
			$this->trace("stSetFirstPlayer: Player $momentum_player has momentum and goes first");
			$this->gamestate->changeActivePlayer($momentum_player);
			
			// Clear momentum after using it
			$this->setGameStateValue("momentum_player", 0);
			
		} else {
			// Normal logic: offense player goes first
			$offense_player_id = $this->getGameStateValue("position_offense");
			
			$this->trace("stSetFirstPlayer: No momentum, offense player $offense_player_id goes first");
			
			if ($offense_player_id == 0) {
				throw new \BgaSystemException("No offense player set in stSetFirstPlayer");
			}
			
			$this->gamestate->changeActivePlayer($offense_player_id);
		}
		
		$this->trace("stSetFirstPlayer: COMPLETE - transitioning to first player turn");
		$this->gamestate->nextState("startRound");
	}
    /**
     * Switch from first player to second player
     */
    public function stSwitchToSecondPlayer(): void
    {
        $this->trace("stSwitchToSecondPlayer: START");
        
        $current_player_id = (int)$this->getActivePlayerId();
        $this->trace("stSwitchToSecondPlayer: Current player: $current_player_id");
        
        // Get both players
        $players = $this->getCollectionFromDB("SELECT player_id FROM player");
        $player_ids = array_keys($players);
        
        $this->trace("stSwitchToSecondPlayer: All player IDs: " . implode(', ', $player_ids));
        
        // Find the other player (the one who will play second)
        $second_player_id = null;
        foreach ($player_ids as $pid) {
            if ($pid != $current_player_id) {
                $second_player_id = $pid;
                break;
            }
        }
        
        if ($second_player_id === null) {
            throw new \BgaSystemException("Could not determine second player");
        }
        
        $this->trace("stSwitchToSecondPlayer: Setting second player to: $second_player_id");
        
        // Set the active player to the second player
        $this->gamestate->changeActivePlayer($second_player_id);
        
        $this->trace("stSwitchToSecondPlayer: COMPLETE - transitioning to second player turn");
        $this->gamestate->nextState("secondPlayerReady");
    }

    /**
     * Switch to second player for dice rolling - FIXED
     */
    public function stSwitchToSecondPlayerForDice(): void
    {
        $this->trace("stSwitchToSecondPlayerForDice: START");
        
        $current_player_id = (int)$this->getActivePlayerId();
        $this->trace("stSwitchToSecondPlayerForDice: Current player: $current_player_id");
        
        // Get both players
        $players = $this->getCollectionFromDB("SELECT player_id FROM player");
        $player_ids = array_keys($players);
        
        // Find the other player
        $second_player_id = null;
        foreach ($player_ids as $pid) {
            if ($pid != $current_player_id) {
                $second_player_id = $pid;
                break;
            }
        }
        
        if ($second_player_id === null) {
            throw new \BgaSystemException("Could not determine second player for dice rolling");
        }
        
        $this->trace("stSwitchToSecondPlayerForDice: Setting second player to: $second_player_id");
        
        // Set the active player to the second player
        $this->gamestate->changeActivePlayer($second_player_id);
        
        $this->trace("stSwitchToSecondPlayerForDice: COMPLETE");
        
        // FIXED: Use the correct transition name
        $this->gamestate->nextState('secondPlayerDice');
    }
    
    /**
     * Set first player for dice rolling - FIXED
     */
    public function stSetFirstPlayerForDice(): void
    {
        $this->trace("stSetFirstPlayerForDice: START");
        
        // Get the first player (offense player goes first for dice rolling too)
        $first_player_id = $this->getGameStateValue("position_offense");
        
        $this->trace("stSetFirstPlayerForDice: Setting first player $first_player_id as active for dice rolling");
        
        // Set the active player
        $this->gamestate->changeActivePlayer($first_player_id);
        
        $this->trace("stSetFirstPlayerForDice: COMPLETE");
        
        // FIXED: Use the correct transition name
        $this->gamestate->nextState('firstPlayerDice');
    }

    /**
     * Set the next player for the round - IMPROVED
     */
	// 4. UPDATED: stSetNextPlayer method to check for momentum
	public function stSetNextPlayer(): void 
	{
		$this->trace("stSetNextPlayer: START");
		
		// Check if anyone has momentum
		$momentum_player = (int)$this->getGameStateValue("momentum_player");
		
		if ($momentum_player > 0) {
			// Player with momentum goes first
			$this->trace("stSetNextPlayer: Player $momentum_player has momentum and goes first");
			$this->gamestate->changeActivePlayer($momentum_player);
			
			// Clear momentum after using it
			$this->setGameStateValue("momentum_player", 0);
			
		} else {
			// Normal logic: alternate players or use standard order
			$current_player_id = (int)$this->getActivePlayerId();
			
			// Get both players
			$players = $this->getCollectionFromDB("SELECT player_id FROM player");
			$player_ids = array_keys($players);
			
			// Find the other player
			$next_player_id = null;
			foreach ($player_ids as $pid) {
				if ($pid != $current_player_id) {
					$next_player_id = $pid;
					break;
				}
			}
			
			if ($next_player_id === null) {
				throw new \BgaSystemException("Could not determine next player");
			}
			
			$this->trace("stSetNextPlayer: Setting next player to: $next_player_id");
			$this->gamestate->changeActivePlayer($next_player_id);
		}
		
		$this->trace("stSetNextPlayer: COMPLETE - transitioning to next player turn");
		$this->gamestate->nextState("nextPlayer");
	}


    public function actPass(): void
    {
        $player_id = (int)$this->getActivePlayerId();
        $player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $player_id");
        if (!$player_name) {
            $player_name = "Player $player_id"; // Fallback if name not found
        }

        $this->notifyAllPlayers("pass", '${player_name} passes', [
            "player_id" => $player_id,
            "player_name" => $player_name,
        ]);

        $this->gamestate->nextState("pass");
    }

    /**
     * Arguments for wrestler selection
     */
    public function argWrestlerSelection(): array
    {
        $this->trace("argWrestlerSelection: START");
        
        $available_wrestlers = [];
        
        // Better query for selected wrestlers
        $selected_wrestlers = $this->getObjectListFromDB("SELECT wrestler_id FROM player WHERE wrestler_id IS NOT NULL AND wrestler_id != 0");
        $selected_ids = array_column($selected_wrestlers, 'wrestler_id');
        
        $this->trace("argWrestlerSelection: Selected wrestler IDs: " . implode(', ', $selected_ids));

        // Return only available wrestlers
        foreach (self::$WRESTLERS as $id => $wrestler) {
            if (!in_array($id, $selected_ids)) {
                $available_wrestlers[$id] = $wrestler;
            }
        }

        $this->trace("argWrestlerSelection: Available wrestlers: " . implode(', ', array_keys($available_wrestlers)));

        return [
            "available_wrestlers" => $available_wrestlers
        ];
    }

    /**
     * Updated argPlayerTurn using robust player detection - IMPROVED with error handling
     */
    public function argPlayerTurn(): array
    {
        $player_id = $this->getTurnPlayerId();
        
        $this->trace("argPlayerTurn: START for player $player_id");
        
        // Get player's current position - ADD ERROR HANDLING
        try {
            $current_position = $this->getPlayerPosition($player_id);
        } catch (Exception $e) {
            $this->trace("argPlayerTurn: ERROR getting position for player $player_id: " . $e->getMessage());
            $current_position = 'offense'; // Safe fallback
        }
        
        $this->trace("argPlayerTurn: Player $player_id current position: $current_position");
        
        // Get all available cards for this position
        $available_cards = $this->getAvailableCardsForPosition($current_position);
        $this->trace("argPlayerTurn: Available cards for position $current_position: " . implode(', ', $available_cards));
        
        // Get player resources for debugging
        $player_data = $this->getObjectFromDB(
            "SELECT conditioning, special_tokens FROM player WHERE player_id = $player_id"
        );
        
        if (!$player_data) {
            $this->trace("argPlayerTurn: ERROR - Could not find player data for player $player_id");
            // Return safe defaults instead of throwing exception
            return [
                "playableCardsIds" => [25], // Just stall card
                "current_position" => $current_position,
            ];
        }
        
        $this->trace("argPlayerTurn: Player $player_id resources - conditioning: {$player_data['conditioning']}, tokens: {$player_data['special_tokens']}");
        
        // Filter to only cards the player can afford
        $playable_cards = [];
        foreach ($available_cards as $card_id) {
            $can_afford = $this->canAffordCard($player_id, $card_id);
            $card = self::$CARD_TYPES[$card_id];
            $this->trace("argPlayerTurn: Card $card_id ({$card['card_name']}) - cost: {$card['conditioning_cost']}, tokens: {$card['special_tokens']}, can afford: " . ($can_afford ? 'YES' : 'NO'));
            
            if ($can_afford) {
                $playable_cards[] = $card_id;
            }
        }
        
        // If no cards are affordable, player can at least play Stall (card 25)
        if (empty($playable_cards)) {
            $this->trace("argPlayerTurn: No affordable cards, adding Stall (25)");
            $playable_cards[] = 25; // Stall card costs 0
        }
        
        $this->trace("argPlayerTurn: Final playable cards for player $player_id: " . implode(', ', $playable_cards));
        
        return [
            "playableCardsIds" => $playable_cards,
            "current_position" => $current_position,
        ];
    }
    
    /**
     * Get the player ID for the current turn - more robust method - IMPROVED
     */
    private function getTurnPlayerId(): int
    {
        // Try multiple methods to get the player ID
        $active_player = (int)$this->getActivePlayerId();
        $current_player = (int)$this->getCurrentPlayerId();
        $state_name = $this->gamestate->state()['name'];
        
        $this->trace("getTurnPlayerId: active=$active_player, current=$current_player, state=$state_name");
        
        // For first player turn, use offense player
        if ($state_name === 'firstPlayerTurn') {
            $offense_player = (int)$this->getGameStateValue("position_offense");
            if ($offense_player > 0) {
                $this->trace("getTurnPlayerId: First player turn, using offense player: $offense_player");
                return $offense_player;
            }
        }
        
        // For second player turn, use defense player
        if ($state_name === 'secondPlayerTurn') {
            $defense_player = (int)$this->getGameStateValue("position_defense");
            if ($defense_player > 0) {
                $this->trace("getTurnPlayerId: Second player turn, using defense player: $defense_player");
                return $defense_player;
            }
        }
        
        // Fallback to active player if valid
        if ($active_player > 0) {
            $this->trace("getTurnPlayerId: Using active player: $active_player");
            return $active_player;
        }
        
        // Final fallback to current player
        if ($current_player > 0) {
            $this->trace("getTurnPlayerId: Using current player: $current_player");
            return $current_player;
        }
        
        // LAST RESORT: Get first player from database
        $first_player = (int)$this->getUniqueValueFromDB("SELECT player_id FROM player LIMIT 1");
        if ($first_player > 0) {
            $this->trace("getTurnPlayerId: EMERGENCY fallback to first player: $first_player");
            return $first_player;
        }
        
        throw new \BgaSystemException("Could not determine player ID for turn");
    }

    /**
     * Start match after wrestler selection
     */
    public function stStartMatch(): void
    {
        $this->trace("stStartMatch: START");
        
        // Set initial game state values
        $this->setGameStateInitialValue("current_period", 1);
        $this->setGameStateInitialValue("current_round", 1);

        // Determine who starts based on conditioning
        $players = $this->getCollectionFromDB(
            "SELECT player_id, player_name, conditioning FROM player ORDER BY conditioning DESC, player_id ASC"
        );
        
        if (empty($players)) {
            throw new \BgaSystemException("No players found in stStartMatch");
        }
        
        $first_player_id = array_key_first($players);
        $this->trace("stStartMatch: First player (highest conditioning): $first_player_id");
        
        // Set the active player
        $this->gamestate->changeActivePlayer($first_player_id);
        
        // Notify about who gets to choose starting position
        $first_player = $players[$first_player_id];
        $this->notifyAllPlayers("startingPositionChoice", 
            '${player_name} has higher conditioning (${conditioning}) and chooses starting position', [
            "player_name" => $first_player['player_name'],
            "conditioning" => $first_player['conditioning']
        ]);

        $this->trace("stStartMatch: COMPLETE - transitioning to position selection");
        $this->gamestate->nextState("startGame");
    }

    /**
     * Game progression
     */
    public function getGameProgression()
    {
        // Simple progression based on current period/round
        $period = $this->getGameStateValue("current_period");
        $round = $this->getGameStateValue("current_round");
        
        // 3 periods: 9, 6, 6 rounds = 21 total rounds
        $total_rounds = 21;
        $completed_rounds = 0;
        
        if ($period > 1) $completed_rounds += 9; // Period 1
        if ($period > 2) $completed_rounds += 6; // Period 2
        if ($period == 3) $completed_rounds += $round; // Current period 3
        else if ($period <= 2) $completed_rounds += $round; // Current period 1 or 2

        return min(100, intval($completed_rounds * 100 / $total_rounds));
    }

    /**
     * Get all game data - IMPROVED with safety checks
     */
    protected function getAllDatas(): array
    {
        $result = [];
        $current_player_id = (int) $this->getCurrentPlayerId();

        try {
            // Get player information including wrestler data
            $result["players"] = $this->getCollectionFromDb(
                "SELECT 
                    player_id id, 
                    player_score score, 
                    player_name name,
                    wrestler_id,
                    conditioning,
                    offense,
                    defense,
                    top,
                    bottom,
                    special_tokens,
                    stall_count 
                FROM player"
            );

            // Add wrestler details - with safety checks
            foreach ($result["players"] as &$player) {
                if ($player['wrestler_id'] && isset(self::$WRESTLERS[$player['wrestler_id']])) {
                    $player['wrestler'] = self::$WRESTLERS[$player['wrestler_id']];
                } else {
                    $player['wrestler'] = null;
                }
            }

            // Get available wrestlers for selection
            $result["wrestlers"] = self::$WRESTLERS;
            
			// Get game state info - with safety checks INCLUDING MOMENTUM
			$result["game_state"] = [
				"current_period" => $this->getGameStateValue("current_period") ?? 1,
				"current_round" => $this->getGameStateValue("current_round") ?? 1,
				"momentum_player" => $this->getGameStateValue("momentum_player") ?? 0,
				"position_offense" => $this->getGameStateValue("position_offense") ?? 0,
				"position_defense" => $this->getGameStateValue("position_defense") ?? 0
			];

            $result["cardTypes"] = self::$CARD_TYPES;
			$result["scrambleCards"] = self::$SCRAMBLE_CARDS; // ADD THIS LINE

            
		} catch (Exception $e) {
			$this->trace("getAllDatas: ERROR - " . $e->getMessage());
			// Return minimal safe data
			$result = [
				"players" => [],
				"wrestlers" => self::$WRESTLERS,
				"game_state" => [
					"current_period" => 1, 
					"current_round" => 1,
					"momentum_player" => 0,
					"position_offense" => 0,
					"position_defense" => 0
				],
				"cardTypes" => self::$CARD_TYPES,
				"scrambleCards" => self::$SCRAMBLE_CARDS // ADD THIS LINE TOO

			];
		}

		return $result;
			
    }
    
    /**
     * Updated setupNewGame to populate wrestlers
     */
    protected function setupNewGame($players, $options = [])
    {
        $this->trace("setupNewGame: START with " . count($players) . " players");
        
        $gameinfos = $this->getGameinfos();
        $default_colors = $gameinfos['player_colors'];

        $query_values = [];
        foreach ($players as $player_id => $player) {
            $query_values[] = vsprintf("('%s', '%s', '%s', '%s', '%s')", [
                $player_id,
                array_shift($default_colors),
                $player["player_canal"],
                addslashes($player["player_name"]),
                addslashes($player["player_avatar"]),
            ]);
        }

        $this->DbQuery(sprintf(
            "INSERT INTO player (player_id, player_color, player_canal, player_name, player_avatar) VALUES %s",
            implode(",", $query_values)
        ));

        $this->reattributeColorsBasedOnPreferences($players, $gameinfos["player_colors"]);
        $this->reloadPlayersBasicInfos();

        // Populate wrestlers table from material data
        $this->populateWrestlersTable();

        // Set all players as active for wrestler selection
        $this->gamestate->setAllPlayersMultiactive();
        $this->trace("setupNewGame: Set all players multiactive for wrestler selection");
        
        // Initialize game state values
        $this->setGameStateInitialValue("current_period", 1);
        $this->setGameStateInitialValue("current_round", 1);
        
        $this->trace("setupNewGame: COMPLETE");
    }
    
    /**
     * Zombie turn handling
     */
    protected function zombieTurn(array $state, int $active_player): void
    {
        $state_name = $state["name"];
        $this->trace("zombieTurn: Handling zombie for player $active_player in state $state_name");

        if ($state["type"] === "activeplayer") {
            switch ($state_name) {
                case "selectStartingPosition":
                    $this->actSelectPosition("offense");
                    return;
                case "firstPlayerTurn":
                case "secondPlayerTurn":
                    // Auto-play the first available card
                    $args = $this->argPlayerTurn();
                    $playable_cards = $args['playableCardsIds'];
                    if (!empty($playable_cards)) {
                        $this->actPlayCard($playable_cards[0]);
                    }
                    return;
                case "firstPlayerChooseDie":
                case "secondPlayerChooseDie":
                    // Auto-choose red die
                    $this->actChooseDie("red");
                    return;
                case "firstPlayerRerollOption":
                case "secondPlayerRerollOption":
                    // Auto-keep dice
                    $this->actKeepDice();
                    return;
                default:
                    $this->gamestate->nextState("zombiePass");
                    break;
            }
            return;
        }

        if ($state["type"] === "multipleactiveplayer") {
            if ($state_name === "wrestlerSelection") {
                $args = $this->argWrestlerSelection();
                $available = $args['available_wrestlers'];
                if (!empty($available)) {
                    $first_wrestler_id = array_key_first($available);
                    $this->trace("zombieTurn: Auto-selecting wrestler $first_wrestler_id for zombie player $active_player");
                    
                    $wrestler = $available[$first_wrestler_id];
                    $this->DbQuery("UPDATE player SET wrestler_id = $first_wrestler_id WHERE player_id = $active_player");
                    $this->DbQuery("UPDATE player SET conditioning = {$wrestler['conditioning_p1']} WHERE player_id = $active_player");
                    $this->DbQuery("UPDATE player SET offense = {$wrestler['offense']} WHERE player_id = $active_player");
                    $this->DbQuery("UPDATE player SET defense = {$wrestler['defense']} WHERE player_id = $active_player");
                    $this->DbQuery("UPDATE player SET top = {$wrestler['top']} WHERE player_id = $active_player");
                    $this->DbQuery("UPDATE player SET bottom = {$wrestler['bottom']} WHERE player_id = $active_player");
                    $this->DbQuery("UPDATE player SET special_tokens = {$wrestler['special_tokens']} WHERE player_id = $active_player");
                    
                    $player_name = $this->getUniqueValueFromDB("SELECT player_name FROM player WHERE player_id = $active_player");
                    if (!$player_name) {
                        $player_name = "Player $active_player";
                    }                    
                    
                    $this->notifyAllPlayers("wrestlerSelected", '${player_name} selected ${wrestler_name}', [
                        "player_id" => $active_player,
                        "player_name" => $player_name,
                        "wrestler_id" => $first_wrestler_id,
                        "wrestler_name" => $wrestler['name'],
                    ]);
                }
            }
            $this->gamestate->setPlayerNonMultiactive($active_player, '');
            return;
        }

        throw new \feException("Zombie mode not supported at this game state: \"{$state_name}\".");
    }

    /**
     * Upgrade table database
     */
    public function upgradeTableDb($from_version)
    {
        // Database upgrade logic when needed
    }

    /**
     * Get game name
     */
    protected function getGameName()
    {
        return "matrevx";
    }
    /** 
     * NEW: Check if second player needs reroll option 
     */ 
    public function stCheckSecondPlayerReroll(): void 
    { 
        $this->trace("stCheckSecondPlayerReroll: START"); 
 
        $second_player_id = (int)$this->getGameStateValue("second_player_id"); 
        $second_die_choice = $this->getGameStateValue("second_player_die_choice"); 
 
        if ($second_die_choice > 0) { 
            $this->trace("stCheckSecondPlayerReroll: Second player $second_player_id gets reroll option"); 
            $this->gamestate->changeActivePlayer($second_player_id); 
            $this->gamestate->nextState("secondPlayerReroll"); 
        } else { 
            $this->trace("stCheckSecondPlayerReroll: Second player didn't roll, skipping to effects"); 
            $this->gamestate->nextState("noSecondReroll"); 
        } 
    } 
 
    /** 
     * UPDATED: First player reroll now just continues flow 
     */ 
    public function stFirstPlayerReroll(): void 
    { 
        $player_id = (int)$this->getActivePlayerId(); 
        $this->trace("stFirstPlayerReroll: Player $player_id reroll complete, checking second player"); 
        $this->gamestate->nextState("rerolled"); 
    } 
 
    /** 
     * UPDATED: Second player reroll now just continues flow 
     */ 
    public function stSecondPlayerReroll(): void 
    { 
        $player_id = (int)$this->getActivePlayerId(); 
        $this->trace("stSecondPlayerReroll: Player $player_id reroll complete, moving to effects"); 
        $this->gamestate->nextState("rerolled"); 
    }
    /**
     * NEW: Check if player has already played a card this round
     */
    private function hasPlayerPlayedCard(int $player_id): bool
    {
        $first_player_id = $this->getGameStateValue("first_player_id");
        $second_player_id = $this->getGameStateValue("second_player_id");
        
        return ($player_id == $first_player_id && $this->getGameStateValue("first_player_card") > 0) ||
               ($player_id == $second_player_id && $this->getGameStateValue("second_player_card") > 0);
    }

    /**
     * NEW: Store player's card choice
     */
    private function storePlayerCard(int $player_id, int $card_id): void
    {
        $offense_player_id = (int)$this->getGameStateValue("position_offense");
        
        if ($player_id == $offense_player_id) {
            $this->setGameStateValue("first_player_id", $player_id);
            $this->setGameStateValue("first_player_card", $card_id);
        } else {
            $this->setGameStateValue("second_player_id", $player_id);
            $this->setGameStateValue("second_player_card", $card_id);
        }
    }

    /**
     * NEW: Check if all players have selected cards
     */
    private function checkAllPlayersReady(): bool
    {
        $first_card = $this->getGameStateValue("first_player_card");
        $second_card = $this->getGameStateValue("second_player_card");
        
        return ($first_card > 0) && ($second_card > 0);
    }

    /**
     * NEW: Arguments for simultaneous card selection
     */
    public function argCardSelection(): array
    {
        $result = [
            "playableCardsIds" => [],
            "positions" => []
        ];
        
        $players = $this->getCollectionFromDB("SELECT player_id FROM player");
        
        foreach ($players as $player_id => $player_data) {
            $current_position = $this->getPlayerPosition($player_id);
            $available_cards = $this->getAvailableCardsForPosition($current_position);
            
            $playable_cards = [];
            foreach ($available_cards as $card_id) {
                if ($this->canAffordCard($player_id, $card_id)) {
                    $playable_cards[] = $card_id;
                }
            }
            
            if (empty($playable_cards)) {
                $playable_cards[] = 25; // Stall card
            }
            
            $result["playableCardsIds"][$player_id] = $playable_cards;
            $result["positions"][$player_id] = $current_position;
        }
        
        return $result;
    }
 
}
?> 



